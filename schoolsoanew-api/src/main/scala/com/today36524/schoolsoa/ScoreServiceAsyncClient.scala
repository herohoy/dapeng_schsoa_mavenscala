package com.today36524.schoolsoa

        import com.isuwang.dapeng.core._
        import com.isuwang.org.apache.thrift._
        import com.isuwang.dapeng.remoting.BaseCommonServiceClient
        import com.today36524.schoolsoa.ScoreServiceCodec._
        import scala.concurrent.{Future, Promise}
        import java.util.function.BiConsumer

        /**
         * Autogenerated by Dapeng-Code-Generator (1.2.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated

        **/
        object ScoreServiceAsyncClient extends BaseCommonServiceClient("com.today36524.schoolsoa.service.ScoreService", "1.0.0"){

        override def isSoaTransactionalProcess: Boolean = {

          var isSoaTransactionalProcess = false
          
          isSoaTransactionalProcess
        }

        
            /**
            * 

    query student

            **/
            def findScoreByStudentIdAndLessonName(id:String , timeout: Long) : scala.concurrent.Future[com.today36524.schoolsoa.bean.Score] = {

            initContext("findScoreByStudentIdAndLessonName");

            try {
              val _responseFuture = sendBaseAsync(findScoreByStudentIdAndLessonName_args(id), new FindScoreByStudentIdAndLessonName_argsSerializer(), new FindScoreByStudentIdAndLessonName_resultSerializer(), timeout).asInstanceOf[java.util.concurrent.CompletableFuture[findScoreByStudentIdAndLessonName_result]]

              val promise = Promise[com.today36524.schoolsoa.bean.Score]()

              _responseFuture.whenComplete(new BiConsumer[findScoreByStudentIdAndLessonName_result, Throwable]{

              override def accept(r: findScoreByStudentIdAndLessonName_result, e: Throwable): Unit = {
                if(e != null)
                  promise.failure(e)
                else
                  promise.success(r.success)
                }
              })
              promise.future
            }catch{
              case e: SoaException => throw e
              case e: TException => throw new SoaException(e)
            }finally {
              destoryContext()
            }
          }
          
            /**
            * 
            **/
            def findScoresByStudentId(studentId:String , timeout: Long) : scala.concurrent.Future[List[com.today36524.schoolsoa.bean.Score]] = {

            initContext("findScoresByStudentId");

            try {
              val _responseFuture = sendBaseAsync(findScoresByStudentId_args(studentId), new FindScoresByStudentId_argsSerializer(), new FindScoresByStudentId_resultSerializer(), timeout).asInstanceOf[java.util.concurrent.CompletableFuture[findScoresByStudentId_result]]

              val promise = Promise[List[com.today36524.schoolsoa.bean.Score]]()

              _responseFuture.whenComplete(new BiConsumer[findScoresByStudentId_result, Throwable]{

              override def accept(r: findScoresByStudentId_result, e: Throwable): Unit = {
                if(e != null)
                  promise.failure(e)
                else
                  promise.success(r.success)
                }
              })
              promise.future
            }catch{
              case e: SoaException => throw e
              case e: TException => throw new SoaException(e)
            }finally {
              destoryContext()
            }
          }
          
            /**
            * 
            **/
            def findAllScores( timeout: Long) : scala.concurrent.Future[List[com.today36524.schoolsoa.bean.Score]] = {

            initContext("findAllScores");

            try {
              val _responseFuture = sendBaseAsync(findAllScores_args(), new FindAllScores_argsSerializer(), new FindAllScores_resultSerializer(), timeout).asInstanceOf[java.util.concurrent.CompletableFuture[findAllScores_result]]

              val promise = Promise[List[com.today36524.schoolsoa.bean.Score]]()

              _responseFuture.whenComplete(new BiConsumer[findAllScores_result, Throwable]{

              override def accept(r: findAllScores_result, e: Throwable): Unit = {
                if(e != null)
                  promise.failure(e)
                else
                  promise.success(r.success)
                }
              })
              promise.future
            }catch{
              case e: SoaException => throw e
              case e: TException => throw new SoaException(e)
            }finally {
              destoryContext()
            }
          }
          

      }
      